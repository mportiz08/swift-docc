{"primaryContentSections":[{"kind":"declarations","declarations":[{"tokens":[{"kind":"keyword","text":"enum"},{"kind":"text","text":" "},{"kind":"identifier","text":"Types"}],"languages":["swift"],"platforms":["macOS"]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/nio\/channeloptions\/types"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/org.swift.docc\/documentation\/NIO\/ChannelOptions\/Types","interfaceLanguage":"swift"},"topicSections":[{"title":"Structures","identifiers":["doc:\/\/org.swift.docc\/documentation\/NIO\/ChannelOptions\/Types\/AllocatorOption","doc:\/\/org.swift.docc\/documentation\/NIO\/ChannelOptions\/Types\/AllowRemoteHalfClosureOption","doc:\/\/org.swift.docc\/documentation\/NIO\/ChannelOptions\/Types\/AutoReadOption","doc:\/\/org.swift.docc\/documentation\/NIO\/ChannelOptions\/Types\/BacklogOption","doc:\/\/org.swift.docc\/documentation\/NIO\/ChannelOptions\/Types\/ConnectTimeoutOption","doc:\/\/org.swift.docc\/documentation\/NIO\/ChannelOptions\/Types\/DatagramVectorReadMessageCountOption","doc:\/\/org.swift.docc\/documentation\/NIO\/ChannelOptions\/Types\/ExplicitCongestionNotificationsOption","doc:\/\/org.swift.docc\/documentation\/NIO\/ChannelOptions\/Types\/MaxMessagesPerReadOption","doc:\/\/org.swift.docc\/documentation\/NIO\/ChannelOptions\/Types\/ReceivePacketInfo","doc:\/\/org.swift.docc\/documentation\/NIO\/ChannelOptions\/Types\/RecvAllocatorOption","doc:\/\/org.swift.docc\/documentation\/NIO\/ChannelOptions\/Types\/SocketOption","doc:\/\/org.swift.docc\/documentation\/NIO\/ChannelOptions\/Types\/WriteBufferWaterMark","doc:\/\/org.swift.docc\/documentation\/NIO\/ChannelOptions\/Types\/WriteBufferWaterMarkOption","doc:\/\/org.swift.docc\/documentation\/NIO\/ChannelOptions\/Types\/WriteSpinOption"]},{"title":"Enumerations","identifiers":["doc:\/\/org.swift.docc\/documentation\/NIO\/ChannelOptions\/Types\/ConvenienceOptionValue"]}],"kind":"symbol","metadata":{"navigatorTitle":[{"kind":"identifier","text":"Types"}],"role":"symbol","title":"ChannelOptions.Types","roleHeading":"Enumeration","fragments":[{"kind":"keyword","text":"enum"},{"kind":"text","text":" "},{"kind":"identifier","text":"Types"}],"symbolKind":"enum","externalID":"s:3NIO14ChannelOptionsV5TypesO","extendedModule":"NIO","modules":[{"name":"NIO"}]},"hierarchy":{"paths":[["doc:\/\/org.swift.docc\/documentation\/NIO","doc:\/\/org.swift.docc\/documentation\/NIO\/ChannelOptions"]]},"references":{"doc://org.swift.docc/documentation/NIO/ChannelOptions":{"role":"symbol","title":"ChannelOptions","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"ChannelOptions"}],"abstract":[{"type":"text","text":"Provides "},{"type":"codeVoice","code":"ChannelOption"},{"type":"text","text":"s to be used with a "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":", "},{"type":"codeVoice","code":"Bootstrap"},{"type":"text","text":" or "},{"type":"codeVoice","code":"ServerBootstrap"},{"type":"text","text":"."}],"identifier":"doc:\/\/org.swift.docc\/documentation\/NIO\/ChannelOptions","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ChannelOptions"}],"url":"\/documentation\/nio\/channeloptions"},"doc://org.swift.docc/documentation/NIO/ChannelOptions/Types/ConvenienceOptionValue":{"role":"symbol","title":"ChannelOptions.Types.ConvenienceOptionValue","fragments":[{"kind":"keyword","text":"enum"},{"kind":"text","text":" "},{"kind":"identifier","text":"ConvenienceOptionValue"}],"abstract":[{"type":"text","text":"Has an option been set?"},{"type":"text","text":" "},{"type":"text","text":"Option has a value of generic type ValueType."}],"identifier":"doc:\/\/org.swift.docc\/documentation\/NIO\/ChannelOptions\/Types\/ConvenienceOptionValue","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ConvenienceOptionValue"}],"url":"\/documentation\/nio\/channeloptions\/types\/convenienceoptionvalue"},"doc://org.swift.docc/documentation/NIO/ChannelOptions/Types/WriteBufferWaterMark":{"role":"symbol","title":"ChannelOptions.Types.WriteBufferWaterMark","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"WriteBufferWaterMark"}],"abstract":[{"type":"text","text":"The watermark used to detect when "},{"type":"codeVoice","code":"Channel.isWritable"},{"type":"text","text":" returns "},{"type":"codeVoice","code":"true"},{"type":"text","text":" or "},{"type":"codeVoice","code":"false"},{"type":"text","text":"."}],"identifier":"doc:\/\/org.swift.docc\/documentation\/NIO\/ChannelOptions\/Types\/WriteBufferWaterMark","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"WriteBufferWaterMark"}],"url":"\/documentation\/nio\/channeloptions\/types\/writebufferwatermark"},"doc://org.swift.docc/documentation/NIO/ChannelOptions/Types/ExplicitCongestionNotificationsOption":{"role":"symbol","title":"ChannelOptions.Types.ExplicitCongestionNotificationsOption","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"ExplicitCongestionNotificationsOption"}],"abstract":[{"type":"text","text":"When set to true IP level ECN information will be reported through "},{"type":"codeVoice","code":"AddressedEnvelope.Metadata"}],"identifier":"doc:\/\/org.swift.docc\/documentation\/NIO\/ChannelOptions\/Types\/ExplicitCongestionNotificationsOption","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ExplicitCongestionNotificationsOption"}],"url":"\/documentation\/nio\/channeloptions\/types\/explicitcongestionnotificationsoption"},"doc://org.swift.docc/documentation/NIO/ChannelOptions/Types/WriteSpinOption":{"role":"symbol","title":"ChannelOptions.Types.WriteSpinOption","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"WriteSpinOption"}],"abstract":[{"type":"codeVoice","code":"WriteSpinOption"},{"type":"text","text":" allows users to configure the number of repetitions of a only partially successful write call before considering the "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":" not writable."},{"type":"text","text":" "},{"type":"text","text":"Setting this option to "},{"type":"codeVoice","code":"0"},{"type":"text","text":" means that we only issue one write call and if that call does not write all the bytes,"},{"type":"text","text":" "},{"type":"text","text":"we consider the "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":" not writable."}],"identifier":"doc:\/\/org.swift.docc\/documentation\/NIO\/ChannelOptions\/Types\/WriteSpinOption","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"WriteSpinOption"}],"url":"\/documentation\/nio\/channeloptions\/types\/writespinoption"},"doc://org.swift.docc/documentation/NIO/ChannelOptions/Types/ReceivePacketInfo":{"role":"symbol","title":"ChannelOptions.Types.ReceivePacketInfo","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"ReceivePacketInfo"}],"abstract":[{"type":"text","text":"When set to true IP level Packet Info information will be reported through "},{"type":"codeVoice","code":"AddressedEnvelope.Metadata"},{"type":"text","text":" for UDP packets."}],"identifier":"doc:\/\/org.swift.docc\/documentation\/NIO\/ChannelOptions\/Types\/ReceivePacketInfo","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ReceivePacketInfo"}],"url":"\/documentation\/nio\/channeloptions\/types\/receivepacketinfo"},"doc://org.swift.docc/documentation/NIO/ChannelOptions/Types/MaxMessagesPerReadOption":{"role":"symbol","title":"ChannelOptions.Types.MaxMessagesPerReadOption","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"MaxMessagesPerReadOption"}],"abstract":[{"type":"codeVoice","code":"MaxMessagesPerReadOption"},{"type":"text","text":" allows users to configure the maximum number of read calls to the underlying transport are performed before wait again until"},{"type":"text","text":" "},{"type":"text","text":"there is more to read and be notified."}],"identifier":"doc:\/\/org.swift.docc\/documentation\/NIO\/ChannelOptions\/Types\/MaxMessagesPerReadOption","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"MaxMessagesPerReadOption"}],"url":"\/documentation\/nio\/channeloptions\/types\/maxmessagesperreadoption"},"doc://org.swift.docc/documentation/NIO/ChannelOptions/Types/AllocatorOption":{"role":"symbol","title":"ChannelOptions.Types.AllocatorOption","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"AllocatorOption"}],"abstract":[{"type":"codeVoice","code":"AllocatorOption"},{"type":"text","text":" allows to specify the "},{"type":"codeVoice","code":"ByteBufferAllocator"},{"type":"text","text":" to use."}],"identifier":"doc:\/\/org.swift.docc\/documentation\/NIO\/ChannelOptions\/Types\/AllocatorOption","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"AllocatorOption"}],"url":"\/documentation\/nio\/channeloptions\/types\/allocatoroption"},"doc://org.swift.docc/documentation/NIO/ChannelOptions/Types/BacklogOption":{"role":"symbol","title":"ChannelOptions.Types.BacklogOption","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"BacklogOption"}],"abstract":[{"type":"codeVoice","code":"BacklogOption"},{"type":"text","text":" allows users to configure the "},{"type":"codeVoice","code":"backlog"},{"type":"text","text":" value as specified in "},{"type":"codeVoice","code":"man 2 listen"},{"type":"text","text":". This is only useful for "},{"type":"codeVoice","code":"ServerSocketChannel"},{"type":"text","text":"s."}],"identifier":"doc:\/\/org.swift.docc\/documentation\/NIO\/ChannelOptions\/Types\/BacklogOption","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"BacklogOption"}],"url":"\/documentation\/nio\/channeloptions\/types\/backlogoption"},"doc://org.swift.docc/documentation/NIO/ChannelOptions/Types/ConnectTimeoutOption":{"role":"symbol","title":"ChannelOptions.Types.ConnectTimeoutOption","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"ConnectTimeoutOption"}],"abstract":[{"type":"codeVoice","code":"ConnectTimeoutOption"},{"type":"text","text":" allows users to configure the "},{"type":"codeVoice","code":"TimeAmount"},{"type":"text","text":" after which a connect will fail if it was not established in the meantime. May be"},{"type":"text","text":" "},{"type":"codeVoice","code":"nil"},{"type":"text","text":", in which case the connection attempt will never time out."}],"identifier":"doc:\/\/org.swift.docc\/documentation\/NIO\/ChannelOptions\/Types\/ConnectTimeoutOption","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ConnectTimeoutOption"}],"url":"\/documentation\/nio\/channeloptions\/types\/connecttimeoutoption"},"doc://org.swift.docc/documentation/NIO/ChannelOptions/Types/DatagramVectorReadMessageCountOption":{"role":"symbol","title":"ChannelOptions.Types.DatagramVectorReadMessageCountOption","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"DatagramVectorReadMessageCountOption"}],"abstract":[{"type":"codeVoice","code":"DatagramVectorReadMessageCountOption"},{"type":"text","text":" allows users to configure the number of messages to attempt to read in a single syscall on a"},{"type":"text","text":" "},{"type":"text","text":"datagram "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":"."}],"identifier":"doc:\/\/org.swift.docc\/documentation\/NIO\/ChannelOptions\/Types\/DatagramVectorReadMessageCountOption","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"DatagramVectorReadMessageCountOption"}],"url":"\/documentation\/nio\/channeloptions\/types\/datagramvectorreadmessagecountoption"},"doc://org.swift.docc/documentation/NIO/ChannelOptions/Types/SocketOption":{"role":"symbol","title":"ChannelOptions.Types.SocketOption","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"SocketOption"}],"abstract":[{"type":"codeVoice","code":"SocketOption"},{"type":"text","text":" allows users to specify configuration settings that are directly applied to the underlying socket file descriptor."}],"identifier":"doc:\/\/org.swift.docc\/documentation\/NIO\/ChannelOptions\/Types\/SocketOption","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"SocketOption"}],"url":"\/documentation\/nio\/channeloptions\/types\/socketoption"},"doc://org.swift.docc/documentation/NIO/ChannelOptions/Types":{"role":"symbol","title":"ChannelOptions.Types","fragments":[{"kind":"keyword","text":"enum"},{"kind":"text","text":" "},{"kind":"identifier","text":"Types"}],"abstract":[],"identifier":"doc:\/\/org.swift.docc\/documentation\/NIO\/ChannelOptions\/Types","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Types"}],"url":"\/documentation\/nio\/channeloptions\/types"},"doc://org.swift.docc/documentation/NIO/ChannelOptions/Types/AllowRemoteHalfClosureOption":{"role":"symbol","title":"ChannelOptions.Types.AllowRemoteHalfClosureOption","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"AllowRemoteHalfClosureOption"}],"abstract":[{"type":"codeVoice","code":"AllowRemoteHalfClosureOption"},{"type":"text","text":" allows users to configure whether the "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":" will close itself when its remote"},{"type":"text","text":" "},{"type":"text","text":"peer shuts down its send stream, or whether it will remain open. If set to "},{"type":"codeVoice","code":"false"},{"type":"text","text":" (the default), the "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":" "},{"type":"text","text":"will be closed automatically if the remote peer shuts down its send stream. If set to true, the "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":" will"},{"type":"text","text":" "},{"type":"text","text":"not be closed: instead, a "},{"type":"codeVoice","code":"ChannelEvent.inboundClosed"},{"type":"text","text":" user event will be sent on the "},{"type":"codeVoice","code":"ChannelPipeline"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and no more data will be received."}],"identifier":"doc:\/\/org.swift.docc\/documentation\/NIO\/ChannelOptions\/Types\/AllowRemoteHalfClosureOption","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"AllowRemoteHalfClosureOption"}],"url":"\/documentation\/nio\/channeloptions\/types\/allowremotehalfclosureoption"},"doc://org.swift.docc/documentation/NIO/ChannelOptions/Types/RecvAllocatorOption":{"role":"symbol","title":"ChannelOptions.Types.RecvAllocatorOption","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"RecvAllocatorOption"}],"abstract":[{"type":"codeVoice","code":"RecvAllocatorOption"},{"type":"text","text":" allows users to specify the "},{"type":"codeVoice","code":"RecvByteBufferAllocator"},{"type":"text","text":" to use."}],"identifier":"doc:\/\/org.swift.docc\/documentation\/NIO\/ChannelOptions\/Types\/RecvAllocatorOption","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"RecvAllocatorOption"}],"url":"\/documentation\/nio\/channeloptions\/types\/recvallocatoroption"},"doc://org.swift.docc/documentation/NIO":{"role":"collection","title":"NIO","abstract":[],"identifier":"doc:\/\/org.swift.docc\/documentation\/NIO","kind":"symbol","type":"topic","url":"\/documentation\/nio"},"doc://org.swift.docc/documentation/NIO/ChannelOptions/Types/AutoReadOption":{"role":"symbol","title":"ChannelOptions.Types.AutoReadOption","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"AutoReadOption"}],"abstract":[{"type":"codeVoice","code":"AutoReadOption"},{"type":"text","text":" allows users to configure if a "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":" should automatically call "},{"type":"codeVoice","code":"Channel.read"},{"type":"text","text":" again once all data was read from the transport or"},{"type":"text","text":" "},{"type":"text","text":"if the user is responsible to call "},{"type":"codeVoice","code":"Channel.read"},{"type":"text","text":" manually."}],"identifier":"doc:\/\/org.swift.docc\/documentation\/NIO\/ChannelOptions\/Types\/AutoReadOption","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"AutoReadOption"}],"url":"\/documentation\/nio\/channeloptions\/types\/autoreadoption"},"doc://org.swift.docc/documentation/NIO/ChannelOptions/Types/WriteBufferWaterMarkOption":{"role":"symbol","title":"ChannelOptions.Types.WriteBufferWaterMarkOption","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"WriteBufferWaterMarkOption"}],"abstract":[{"type":"codeVoice","code":"WriteBufferWaterMarkOption"},{"type":"text","text":" allows users to configure when a "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":" should be marked as writable or not. Once the amount of bytes queued in a"},{"type":"text","text":" "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":"s outbound buffer is larger than "},{"type":"codeVoice","code":"WriteBufferWaterMark.high"},{"type":"text","text":" the channel will be marked as non-writable and so"},{"type":"text","text":" "},{"type":"codeVoice","code":"Channel.isWritable"},{"type":"text","text":" will return "},{"type":"codeVoice","code":"false"},{"type":"text","text":". Once we were able to write some data out of the outbound buffer and the amount of bytes queued"},{"type":"text","text":" "},{"type":"text","text":"falls below "},{"type":"codeVoice","code":"WriteBufferWaterMark.low"},{"type":"text","text":" the "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":" will become writable again. Once this happens "},{"type":"codeVoice","code":"Channel.writable"},{"type":"text","text":" will return"},{"type":"text","text":" "},{"type":"codeVoice","code":"true"},{"type":"text","text":" again. These writability changes are also propagated through the "},{"type":"codeVoice","code":"ChannelPipeline"},{"type":"text","text":" and so can be intercepted via "},{"type":"codeVoice","code":"ChannelInboundHandler.channelWritabilityChanged"},{"type":"text","text":"."}],"identifier":"doc:\/\/org.swift.docc\/documentation\/NIO\/ChannelOptions\/Types\/WriteBufferWaterMarkOption","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"WriteBufferWaterMarkOption"}],"url":"\/documentation\/nio\/channeloptions\/types\/writebufferwatermarkoption"}}}