{"primaryContentSections":[{"kind":"declarations","declarations":[{"tokens":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"ByteToMessageDecoder"}],"languages":["swift"],"platforms":["macOS"]}]},{"kind":"content","content":[{"anchor":"Purpose","level":3,"type":"heading","text":"Purpose"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" provides a simplified API for handling streams of incoming data that can be broken"},{"type":"text","text":" "},{"type":"text","text":"up into messages. This API boils down to two methods: "},{"type":"codeVoice","code":"decode"},{"type":"text","text":", and "},{"type":"codeVoice","code":"decodeLast"},{"type":"text","text":". These two methods, when"},{"type":"text","text":" "},{"type":"text","text":"implemented, will be used by a "},{"type":"codeVoice","code":"ByteToMessageHandler"},{"type":"text","text":" paired with a "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" to decode the"},{"type":"text","text":" "},{"type":"text","text":"incoming byte stream into a sequence of messages."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The reason this helper exists is to smooth away some of the boilerplate and edge case handling code that"},{"type":"text","text":" "},{"type":"text","text":"is often necessary when implementing parsers in a SwiftNIO "},{"type":"codeVoice","code":"ChannelPipeline"},{"type":"text","text":". A "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" "},{"type":"text","text":"never needs to worry about how inbound bytes will be buffered, as "},{"type":"codeVoice","code":"ByteToMessageHandler"},{"type":"text","text":" deals with that"},{"type":"text","text":" "},{"type":"text","text":"automatically. A "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" also never needs to worry about memory exclusivity violations"},{"type":"text","text":" "},{"type":"text","text":"that can occur when re-entrant "},{"type":"codeVoice","code":"ChannelPipeline"},{"type":"text","text":" operations occur, as "},{"type":"codeVoice","code":"ByteToMessageHandler"},{"type":"text","text":" will deal with"},{"type":"text","text":" "},{"type":"text","text":"those as well."}]},{"anchor":"Implementing-ByteToMessageDecoder","level":3,"type":"heading","text":"Implementing ByteToMessageDecoder"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A type that implements "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" may implement two methods: decode and decodeLast. Implementations"},{"type":"text","text":" "},{"type":"text","text":"must implement decode: if they do not implement decodeLast, a default implementation will be used that"},{"type":"text","text":" "},{"type":"text","text":"simply calls decode."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"decode"},{"type":"text","text":" is the main decoding method, and is the one that will be called most often. "},{"type":"codeVoice","code":"decode"},{"type":"text","text":" is invoked"},{"type":"text","text":" "},{"type":"text","text":"whenever data is received by the wrapping "},{"type":"codeVoice","code":"ByteToMessageHandler"},{"type":"text","text":". It is invoked with a "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" containing"},{"type":"text","text":" "},{"type":"text","text":"all the received data (including any data previously buffered), as well as a "},{"type":"codeVoice","code":"ChannelHandlerContext"},{"type":"text","text":" that can be"},{"type":"text","text":" "},{"type":"text","text":"used in the "},{"type":"codeVoice","code":"decode"},{"type":"text","text":" function."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"decode"},{"type":"text","text":" is called in a loop by the "},{"type":"codeVoice","code":"ByteToMessageHandler"},{"type":"text","text":". This loop continues until one of two cases occurs:"}]},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The input "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" has no more readable bytes (i.e. "},{"type":"codeVoice","code":".readableBytes == 0"},{"type":"text","text":"); OR"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"decode"},{"type":"text","text":" method returns "},{"type":"codeVoice","code":".needMoreData"},{"type":"text","text":"."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The reason this method is invoked in a loop is to ensure that the stream-like properties of inbound data are"},{"type":"text","text":" "},{"type":"text","text":"respected. It is entirely possible for "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" to receive either fewer bytes than a single message,"},{"type":"text","text":" "},{"type":"text","text":"or multiple messages in one go. Rather than have the "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" handle all of the complexity of this,"},{"type":"text","text":" "},{"type":"text","text":"the logic can be boiled down to a single choice: has the "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" been able to move the state forward"},{"type":"text","text":" "},{"type":"text","text":"or not? If it has, rather than containing an internal loop it may simply return "},{"type":"codeVoice","code":".continue"},{"type":"text","text":" in order to request that"},{"type":"text","text":" "},{"type":"codeVoice","code":"decode"},{"type":"text","text":" be invoked again immediately. If it has not, it can return "},{"type":"codeVoice","code":".needMoreData"},{"type":"text","text":" to ask to be left alone until more"},{"type":"text","text":" "},{"type":"text","text":"data has been returned from the network."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Essentially, if the next parsing step could not be taken because there wasn’t enough data available, return "},{"type":"codeVoice","code":".needMoreData"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Otherwise, return "},{"type":"codeVoice","code":".continue"},{"type":"text","text":". This will allow a "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" implementation to ignore the awkward way data"},{"type":"text","text":" "},{"type":"text","text":"arrives from the network, and to just treat it as a series of "},{"type":"codeVoice","code":"decode"},{"type":"text","text":" calls."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"decodeLast"},{"type":"text","text":" is a cousin of "},{"type":"codeVoice","code":"decode"},{"type":"text","text":". It is also called in a loop, but unlike with "},{"type":"codeVoice","code":"decode"},{"type":"text","text":" this loop will only ever"},{"type":"text","text":" "},{"type":"text","text":"occur once: when the "},{"type":"codeVoice","code":"ChannelHandlerContext"},{"type":"text","text":" belonging to this "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" is about to become invalidated."},{"type":"text","text":" "},{"type":"text","text":"This invalidation happens in two situations: when EOF is received from the network, or when the "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" "},{"type":"text","text":"is being removed from the "},{"type":"codeVoice","code":"ChannelPipeline"},{"type":"text","text":". The distinction between these two states is captured by the value of"},{"type":"text","text":" "},{"type":"codeVoice","code":"seenEOF"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this condition, the "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" must now produce any final messages it can with the bytes it has"},{"type":"text","text":" "},{"type":"text","text":"available. In protocols where EOF is used as a message delimiter, having "},{"type":"codeVoice","code":"decodeLast"},{"type":"text","text":" called with "},{"type":"codeVoice","code":"seenEOF == true"},{"type":"text","text":" "},{"type":"text","text":"may produce further messages. In other cases, "},{"type":"codeVoice","code":"decodeLast"},{"type":"text","text":" may choose to deliver any buffered bytes as “leftovers”,"},{"type":"text","text":" "},{"type":"text","text":"either in error messages or via "},{"type":"codeVoice","code":"channelRead"},{"type":"text","text":". This can occur if, for example, a protocol upgrade is occurring."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"As with "},{"type":"codeVoice","code":"decode"},{"type":"text","text":", "},{"type":"codeVoice","code":"decodeLast"},{"type":"text","text":" is invoked in a loop. This allows the same simplification as "},{"type":"codeVoice","code":"decode"},{"type":"text","text":" allows: when"},{"type":"text","text":" "},{"type":"text","text":"a message is completely parsed, the "},{"type":"codeVoice","code":"decodeLast"},{"type":"text","text":" function can return "},{"type":"codeVoice","code":".continue"},{"type":"text","text":" and be re-invoked from the top,"},{"type":"text","text":" "},{"type":"text","text":"rather than containing an internal loop."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that the value of "},{"type":"codeVoice","code":"seenEOF"},{"type":"text","text":" may change between calls to "},{"type":"codeVoice","code":"decodeLast"},{"type":"text","text":" in some rare situations."}]},{"anchor":"Implementers-Notes","level":3,"type":"heading","text":"Implementers Notes"},{"type":"paragraph","inlineContent":[{"type":"text","text":"\/\/\/ "},{"type":"codeVoice","code":"ByteToMessageHandler"},{"type":"text","text":" will turn your "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" into a "},{"type":"codeVoice","code":"ChannelInboundHandler"},{"type":"text","text":". "},{"type":"codeVoice","code":"ByteToMessageHandler"},{"type":"text","text":" "},{"type":"text","text":"also solves a couple of tricky issues for you. Most importantly, in a "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" you do "},{"type":"emphasis","inlineContent":[{"type":"text","text":"not"}]},{"type":"text","text":" need to"},{"type":"text","text":" "},{"type":"text","text":"worry about re-entrancy. Your code owns the passed-in "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" for the duration of the "},{"type":"codeVoice","code":"decode"},{"type":"text","text":"\/"},{"type":"codeVoice","code":"decodeLast"},{"type":"text","text":" call and"},{"type":"text","text":" "},{"type":"text","text":"can modify it at will."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If a custom frame decoder is required, then one needs to be careful when implementing"},{"type":"text","text":" "},{"type":"text","text":"one with "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":". Ensure there are enough bytes in the buffer for a"},{"type":"text","text":" "},{"type":"text","text":"complete frame by checking "},{"type":"codeVoice","code":"buffer.readableBytes"},{"type":"text","text":". If there are not enough bytes"},{"type":"text","text":" "},{"type":"text","text":"for a complete frame, return without modifying the reader index to allow more bytes to arrive."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To check for complete frames without modifying the reader index, use methods like "},{"type":"codeVoice","code":"buffer.getInteger"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"You  "},{"type":"emphasis","inlineContent":[{"type":"text","text":"MUST"}]},{"type":"text","text":" use the reader index when using methods like "},{"type":"codeVoice","code":"buffer.getInteger"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"For example calling "},{"type":"codeVoice","code":"buffer.getInteger(at: 0)"},{"type":"text","text":" is assuming the frame starts at the beginning of the buffer, which"},{"type":"text","text":" "},{"type":"text","text":"is not always the case. Use "},{"type":"codeVoice","code":"buffer.getInteger(at: buffer.readerIndex)"},{"type":"text","text":" instead."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you move the reader index forward, either manually or by using one of "},{"type":"codeVoice","code":"buffer.read*"},{"type":"text","text":" methods, you must ensure"},{"type":"text","text":" "},{"type":"text","text":"that you no longer need to see those bytes again as they will not be returned to you the next time "},{"type":"codeVoice","code":"decode"},{"type":"text","text":" is"},{"type":"text","text":" "},{"type":"text","text":"called. If you still need those bytes to come back, consider taking a local copy of buffer inside the function to"},{"type":"text","text":" "},{"type":"text","text":"perform your read operations on."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" passed in as "},{"type":"codeVoice","code":"buffer"},{"type":"text","text":" is a slice of a larger buffer owned by the "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" "},{"type":"text","text":"implementation. Some aspects of this buffer are preserved across calls to "},{"type":"codeVoice","code":"decode"},{"type":"text","text":", meaning that any changes to"},{"type":"text","text":" "},{"type":"text","text":"those properties you make in your "},{"type":"codeVoice","code":"decode"},{"type":"text","text":" method will be reflected in the next call to decode. In particular,"},{"type":"text","text":" "},{"type":"text","text":"moving the reader index forward persists across calls. When your method returns, if the reader index has advanced,"},{"type":"text","text":" "},{"type":"text","text":"those bytes are considered “consumed” and will not be available in future calls to "},{"type":"codeVoice","code":"decode"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Please note, however, that the numerical value of the "},{"type":"codeVoice","code":"readerIndex"},{"type":"text","text":" itself is not preserved, and may not be the same"},{"type":"text","text":" "},{"type":"text","text":"from one call to the next. Please do not rely on this numerical value: if you need"},{"type":"text","text":" "},{"type":"text","text":"to recall where a byte is relative to the "},{"type":"codeVoice","code":"readerIndex"},{"type":"text","text":", use an offset rather than an absolute value."}]},{"anchor":"Using-ByteToMessageDecoder","level":3,"type":"heading","text":"Using ByteToMessageDecoder"},{"type":"paragraph","inlineContent":[{"type":"text","text":"To add a "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" to the "},{"type":"codeVoice","code":"ChannelPipeline"},{"type":"text","text":" use"}]},{"type":"codeListing","syntax":"markdown","code":["channel.pipeline.addHandler(ByteToMessageHandler(MyByteToMessageDecoder()))"]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/nio\/bytetomessagedecoder"],"traits":[{"interfaceLanguage":"swift"}]}],"relationshipsSections":[{"identifiers":["doc:\/\/org.swift.docc\/documentation\/NIO\/NIOSingleStepByteToMessageDecoder","doc:\/\/org.swift.docc\/documentation\/NIO\/WriteObservingByteToMessageDecoder"],"kind":"relationships","title":"Inherited By","type":"inheritedBy"},{"identifiers":["doc:\/\/org.swift.docc\/documentation\/NIOHTTP1\/HTTPDecoder","doc:\/\/org.swift.docc\/documentation\/NIOTLS\/SNIHandler"],"kind":"relationships","title":"Conforming Types","type":"conformingTypes"}],"identifier":{"url":"doc:\/\/org.swift.docc\/documentation\/NIO\/ByteToMessageDecoder","interfaceLanguage":"swift"},"abstract":[{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":"s decode bytes in a stream-like fashion from "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" to another message type."}],"kind":"symbol","metadata":{"fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"ByteToMessageDecoder"}],"title":"ByteToMessageDecoder","roleHeading":"Protocol","role":"symbol","symbolKind":"protocol","externalID":"s:3NIO20ByteToMessageDecoderP","modules":[{"name":"NIO"}],"navigatorTitle":[{"kind":"identifier","text":"ByteToMessageDecoder"}]},"hierarchy":{"paths":[["doc:\/\/org.swift.docc\/documentation\/NIO"]]},"topicSections":[{"title":"Associated Types","identifiers":["doc:\/\/org.swift.docc\/documentation\/NIO\/ByteToMessageDecoder\/InboundOut"]},{"title":"Instance Methods","identifiers":["doc:\/\/org.swift.docc\/documentation\/NIO\/ByteToMessageDecoder\/decode(context:buffer:)","doc:\/\/org.swift.docc\/documentation\/NIO\/ByteToMessageDecoder\/decodeLast(context:buffer:seenEOF:)-zmdw","doc:\/\/org.swift.docc\/documentation\/NIO\/ByteToMessageDecoder\/decoderAdded(context:)-3fpff","doc:\/\/org.swift.docc\/documentation\/NIO\/ByteToMessageDecoder\/decoderRemoved(context:)-9ghv5","doc:\/\/org.swift.docc\/documentation\/NIO\/ByteToMessageDecoder\/shouldReclaimBytes(buffer:)-5nwwa","doc:\/\/org.swift.docc\/documentation\/NIO\/ByteToMessageDecoder\/wrapInboundOut(_:)"]}],"references":{"doc://org.swift.docc/documentation/NIO/WriteObservingByteToMessageDecoder":{"role":"symbol","title":"WriteObservingByteToMessageDecoder","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"WriteObservingByteToMessageDecoder"}],"abstract":[{"type":"text","text":"Some "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":"s need to observe "},{"type":"codeVoice","code":"write"},{"type":"text","text":"s (which are outbound events). "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":"s which"},{"type":"text","text":" "},{"type":"text","text":"implement the "},{"type":"codeVoice","code":"WriteObservingByteToMessageDecoder"},{"type":"text","text":" protocol will be notified about every outbound write."}],"identifier":"doc:\/\/org.swift.docc\/documentation\/NIO\/WriteObservingByteToMessageDecoder","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"WriteObservingByteToMessageDecoder"}],"url":"\/documentation\/nio\/writeobservingbytetomessagedecoder"},"doc://org.swift.docc/documentation/NIO/ByteToMessageDecoder/wrapInboundOut(_:)":{"role":"symbol","title":"wrapInboundOut(_:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"wrapInboundOut"},{"kind":"text","text":"("},{"kind":"typeIdentifier","text":"InboundOut","preciseIdentifier":"s:3NIO20ByteToMessageDecoderP10InboundOutQa"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"NIOAny","preciseIdentifier":"s:3NIO6NIOAnyV"}],"abstract":[],"identifier":"doc:\/\/org.swift.docc\/documentation\/NIO\/ByteToMessageDecoder\/wrapInboundOut(_:)","kind":"symbol","type":"topic","url":"\/documentation\/nio\/bytetomessagedecoder\/wrapinboundout(_:)"},"doc://org.swift.docc/documentation/NIOTLS/SNIHandler":{"role":"symbol","title":"SNIHandler","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"SNIHandler"}],"abstract":[{"type":"text","text":"A channel handler that can be used to arbitrarily edit a channel"},{"type":"text","text":" "},{"type":"text","text":"pipeline based on the hostname requested in the Server Name Indication"},{"type":"text","text":" "},{"type":"text","text":"portion of the TLS Client Hello."}],"identifier":"doc:\/\/org.swift.docc\/documentation\/NIOTLS\/SNIHandler","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"SNIHandler"}],"url":"\/documentation\/niotls\/snihandler"},"doc://org.swift.docc/documentation/NIO/ByteToMessageDecoder/decodeLast(context:buffer:seenEOF:)-zmdw":{"defaultImplementations":2,"role":"symbol","title":"decodeLast(context:buffer:seenEOF:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"decodeLast"},{"kind":"text","text":"("},{"kind":"externalParam","text":"context"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"ChannelHandlerContext","preciseIdentifier":"s:3NIO21ChannelHandlerContextC"},{"kind":"text","text":", "},{"kind":"externalParam","text":"buffer"},{"kind":"text","text":": "},{"kind":"keyword","text":"inout"},{"kind":"text","text":" "},{"kind":"typeIdentifier","text":"ByteBuffer","preciseIdentifier":"s:3NIO10ByteBufferV"},{"kind":"text","text":", "},{"kind":"externalParam","text":"seenEOF"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Bool","preciseIdentifier":"s:Sb"},{"kind":"text","text":") "},{"kind":"keyword","text":"throws"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"DecodingState","preciseIdentifier":"s:3NIO13DecodingStateO"}],"abstract":[{"type":"text","text":"Decode from a "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" when no more data is incoming and the "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" is about to leave"},{"type":"text","text":" "},{"type":"text","text":"the pipeline."}],"identifier":"doc:\/\/org.swift.docc\/documentation\/NIO\/ByteToMessageDecoder\/decodeLast(context:buffer:seenEOF:)-zmdw","kind":"symbol","required":true,"type":"topic","url":"\/documentation\/nio\/bytetomessagedecoder\/decodelast(context:buffer:seeneof:)-zmdw"},"doc://org.swift.docc/documentation/NIOHTTP1/HTTPDecoder":{"role":"symbol","title":"HTTPDecoder","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"HTTPDecoder"}],"abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"ChannelInboundHandler"},{"type":"text","text":" that parses HTTP\/1-style messages, converting them from"},{"type":"text","text":" "},{"type":"text","text":"unstructured bytes to a sequence of HTTP messages."}],"identifier":"doc:\/\/org.swift.docc\/documentation\/NIOHTTP1\/HTTPDecoder","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"HTTPDecoder"}],"url":"\/documentation\/niohttp1\/httpdecoder"},"doc://org.swift.docc/documentation/NIO/ByteToMessageDecoder/InboundOut":{"role":"symbol","title":"InboundOut","fragments":[{"kind":"keyword","text":"associatedtype"},{"kind":"text","text":" "},{"kind":"identifier","text":"InboundOut"}],"abstract":[{"type":"text","text":"The type of the messages this "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" decodes to."}],"identifier":"doc:\/\/org.swift.docc\/documentation\/NIO\/ByteToMessageDecoder\/InboundOut","kind":"symbol","required":true,"type":"topic","url":"\/documentation\/nio\/bytetomessagedecoder\/inboundout"},"doc://org.swift.docc/documentation/NIO":{"role":"collection","title":"NIO","abstract":[],"identifier":"doc:\/\/org.swift.docc\/documentation\/NIO","kind":"symbol","type":"topic","url":"\/documentation\/nio"},"doc://org.swift.docc/documentation/NIO/ByteToMessageDecoder/decode(context:buffer:)":{"defaultImplementations":1,"role":"symbol","title":"decode(context:buffer:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"decode"},{"kind":"text","text":"("},{"kind":"externalParam","text":"context"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"ChannelHandlerContext","preciseIdentifier":"s:3NIO21ChannelHandlerContextC"},{"kind":"text","text":", "},{"kind":"externalParam","text":"buffer"},{"kind":"text","text":": "},{"kind":"keyword","text":"inout"},{"kind":"text","text":" "},{"kind":"typeIdentifier","text":"ByteBuffer","preciseIdentifier":"s:3NIO10ByteBufferV"},{"kind":"text","text":") "},{"kind":"keyword","text":"throws"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"DecodingState","preciseIdentifier":"s:3NIO13DecodingStateO"}],"abstract":[{"type":"text","text":"Decode from a "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":"."}],"identifier":"doc:\/\/org.swift.docc\/documentation\/NIO\/ByteToMessageDecoder\/decode(context:buffer:)","kind":"symbol","required":true,"type":"topic","url":"\/documentation\/nio\/bytetomessagedecoder\/decode(context:buffer:)"},"doc://org.swift.docc/documentation/NIO/ByteToMessageDecoder/decoderRemoved(context:)-9ghv5":{"defaultImplementations":1,"role":"symbol","title":"decoderRemoved(context:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"decoderRemoved"},{"kind":"text","text":"("},{"kind":"externalParam","text":"context"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"ChannelHandlerContext","preciseIdentifier":"s:3NIO21ChannelHandlerContextC"},{"kind":"text","text":")"}],"abstract":[{"type":"text","text":"Called once this "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" is removed from the "},{"type":"codeVoice","code":"ChannelPipeline"},{"type":"text","text":"."}],"identifier":"doc:\/\/org.swift.docc\/documentation\/NIO\/ByteToMessageDecoder\/decoderRemoved(context:)-9ghv5","kind":"symbol","required":true,"type":"topic","url":"\/documentation\/nio\/bytetomessagedecoder\/decoderremoved(context:)-9ghv5"},"doc://org.swift.docc/documentation/NIO/ByteToMessageDecoder":{"role":"symbol","title":"ByteToMessageDecoder","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"ByteToMessageDecoder"}],"abstract":[{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":"s decode bytes in a stream-like fashion from "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" to another message type."}],"identifier":"doc:\/\/org.swift.docc\/documentation\/NIO\/ByteToMessageDecoder","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ByteToMessageDecoder"}],"url":"\/documentation\/nio\/bytetomessagedecoder"},"doc://org.swift.docc/documentation/NIO/ByteToMessageDecoder/decoderAdded(context:)-3fpff":{"defaultImplementations":1,"role":"symbol","title":"decoderAdded(context:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"decoderAdded"},{"kind":"text","text":"("},{"kind":"externalParam","text":"context"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"ChannelHandlerContext","preciseIdentifier":"s:3NIO21ChannelHandlerContextC"},{"kind":"text","text":")"}],"abstract":[{"type":"text","text":"Called when this "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" is added to the "},{"type":"codeVoice","code":"ChannelPipeline"},{"type":"text","text":"."}],"identifier":"doc:\/\/org.swift.docc\/documentation\/NIO\/ByteToMessageDecoder\/decoderAdded(context:)-3fpff","kind":"symbol","required":true,"type":"topic","url":"\/documentation\/nio\/bytetomessagedecoder\/decoderadded(context:)-3fpff"},"doc://org.swift.docc/documentation/NIO/NIOSingleStepByteToMessageDecoder":{"role":"symbol","title":"NIOSingleStepByteToMessageDecoder","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOSingleStepByteToMessageDecoder"}],"abstract":[{"type":"text","text":"A simplified version of "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" that can generate zero or one messages for each invocation of "},{"type":"codeVoice","code":"decode"},{"type":"text","text":" or "},{"type":"codeVoice","code":"decodeLast"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Having "},{"type":"codeVoice","code":"decode"},{"type":"text","text":" and "},{"type":"codeVoice","code":"decodeLast"},{"type":"text","text":" return an optional message avoids re-entrancy problems, since the functions relinquish exclusive access"},{"type":"text","text":" "},{"type":"text","text":"to the "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" when returning. This allows for greatly simplified processing."}],"identifier":"doc:\/\/org.swift.docc\/documentation\/NIO\/NIOSingleStepByteToMessageDecoder","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"NIOSingleStepByteToMessageDecoder"}],"url":"\/documentation\/nio\/niosinglestepbytetomessagedecoder"},"doc://org.swift.docc/documentation/NIO/ByteToMessageDecoder/shouldReclaimBytes(buffer:)-5nwwa":{"defaultImplementations":1,"role":"symbol","title":"shouldReclaimBytes(buffer:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"shouldReclaimBytes"},{"kind":"text","text":"("},{"kind":"externalParam","text":"buffer"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"ByteBuffer","preciseIdentifier":"s:3NIO10ByteBufferV"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"Bool","preciseIdentifier":"s:Sb"}],"abstract":[{"type":"text","text":"Determine if the read bytes in the given "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" should be reclaimed and their associated memory freed."},{"type":"text","text":" "},{"type":"text","text":"Be aware that reclaiming memory may involve memory copies and so is not free."}],"identifier":"doc:\/\/org.swift.docc\/documentation\/NIO\/ByteToMessageDecoder\/shouldReclaimBytes(buffer:)-5nwwa","kind":"symbol","required":true,"type":"topic","url":"\/documentation\/nio\/bytetomessagedecoder\/shouldreclaimbytes(buffer:)-5nwwa"}}}